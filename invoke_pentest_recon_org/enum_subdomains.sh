#!/bin/bash
SCRIPT_DIR=$(dirname "$0")
DNSCAN_SUBDOMAINS_THRESHOLD=0.85
USAGE="$0 <seed_domains> <seed_ips> [virustotal_key=$VIRUSTOTAL_KEY] [shodan_key=$SHODAN_KEYS]"
TOP_TCP_PORTS=100
NC_BANNER_TIMEOUT=3
SUBDOMAIN_REGEX="[^/]+"
DOMAIN_REGEX="^[a-zA-Z0-9\.\-]+\.[a-zA-Z\.\-]{2,6}$"
IP_REGEX="^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}/?([0-9]{1,2})?$"
CDN_DOMAINS_EXCLUSIONS="in-cdn-domains.txt"
TIMEOUT=300
MAX_CURL_TIMEOUT=5

function verbose {
    msg="$1"
    echo "[*] $msg"
}

if [ $# -lt 2 ]; then
    echo "[-] $USAGE"
    exit 1
fi
seed_domains="$1"
seed_ips="$2"
virustotal_key=${4:-"$VIRUSTOTAL_KEY"}
shodan_key=${5:-"$SHODAN_KEY"}

verbose "Reading seed domains from seeds: $seed_domains..."
if [ -f "$seed_domains" ]; then
    # Also, ignore comments and empty lines
    seed_domains=$(cat "$seed_domains" \
        | grep -iEv "^#|^$" \
        | grep -ioE "$DOMAIN_REGEX" \
        | sort | uniq)
else
    # Also, ignore comments and empty lines
    seed_domains=$(echo "$seed_domains" \
        | grep -iEv "^#|^$" \
        | tr -s "," "\n" \
        | grep -ioE "$DOMAIN_REGEX" \
        | sort | uniq)
fi

verbose "Reading seed IPs, IP ranges from seeds: $seed_ips..."
if [ -f "$seed_ips" ]; then
    seed_ips=$(cat "$seed_ips" \
        | grep -iEv "^#|^$" \
        | grep -ioE "$IP_REGEX" \
        | sort | uniq)
else
    seed_ips=$(echo "$seed_ips" \
        | grep -iEv "^#|^$" \
        | tr -s "," "\n" \
        | grep -ioE "$IP_REGEX" \
        | sort | uniq)
fi

# Set virustotal key for assetfinder
if [ ! -z "$virustotal_key" ]; then
    export VIRUSTOTAL_KEY="$virustotal_key"
fi

# Clearing all output files
rm out-* 2>/dev/null

verbose "Adding seed domains themselves as potential domains..."
echo "$seed_domains"  | /root/go/bin/anew -q "out-domains.csv"

verbose "Creating a temp file for storing intermediate results..."
tmpfile=$(mktemp -u)
tmpfile2=$(mktemp -u)

verbose "Identifying threshold for skipping subdomain dnsenum results..."
num_subdomains_in_dnscan_wordlist=$(wc -l "/opt/dnscan/subdomains.txt" | cut -d " " -f1)
dnscan_subdomains_threshold=$(echo "($DNSCAN_SUBDOMAINS_THRESHOLD * $num_subdomains_in_dnscan_wordlist)/1" | bc)

num_seed_domains=$(echo "$seed_domains" | wc -l)
IFS=$'\n'; i=0
for seed_domain in $seed_domains; do
    i=$(($i + 1))
    echo "[*] $i / $num_seed_domains: Invoking a recon using hakrawler on seed: $seed_domain..."
    echo "https://$seed_domain" | /root/go/bin/hakrawler -subs | grep -ioE "$SUBDOMAIN_REGEX.$seed_domain" | /root/go/bin/anew -q "out-domains.csv"

    echo "[*] $i / $num_seed_domains: Invoking a recon using assetfinder on seed: $seed_domain..."
    /root/go/bin/assetfinder --subs-only "$seed_domain" | grep -ioE "$SUBDOMAIN_REGEX.$seed_domain" | /root/go/bin/anew -q "out-domains.csv"

    echo "[*] $i / $num_seed_domains: Invoking a recon using dnsx and dnscan wordlist on seed: $seed_domain..."
    /root/go/bin/dnsx -silent -a -nc -d "$seed_domain" -w /opt/dnscan/subdomains.txt | grep -ioE "[a-zA-Z0-9\.\-]+$seed_domain" > "$tmpfile" 
    num_subdomains_found=$(wc -l "$tmpfile" | cut -d " " -f1)
    if [[ $num_subdomains_found -lt $dnscan_subdomains_threshold ]]; then 
        cat "$tmpfile" | /root/go/bin/anew -q "out-domains.csv"
    else
        echo "[!] Excluding results for dnscan dnsx enum, as $num_subdomains_found subdomains found"
    fi
done

echo "[*] Appending seed domains to out-domains.csv..."
echo "$seed_domains" | /root/go/bin/anew -q "out-domains.csv"

verbose "Identifying resolvable domains from out-domains.csv..."
cat "out-domains.csv"  | /root/go/bin/dnsx -silent -a -resp -nc -o "out-dns-resolutions-domains.txt"
cat "out-dns-resolutions-domains.txt" | tr -s " " "," | sed -r "s/,$//g" > "out-dns-resolutions-domains.csv"
cat "out-dns-resolutions-domains.txt" | cut -d " " -f1 | sort | uniq > "out-resolvable-domains.csv"
cat "out-dns-resolutions-domains.txt" | cut -d "[" -f3 | cut -d "]" -f1 | sort | uniq > "out-resolvable-ips.csv"

verbose "Identifying CDN domains from out-domains.csv..."
cat "out-domains.csv" | /root/go/bin/cdncheck -resp -nc -silent | grep -iE '\[cdn\]|\[waf\]|\[cloud\]' | cut -d " " -f1 > "out-cdn-domains.txt"

verbose "Identifying resolvable, non-CDN domains from out-cdn-domains.txt..."
grep -Fxv -f "out-cdn-domains.txt"  "out-resolvable-domains.csv" > "out-noncdn-domains-intermediate.txt"

verbose "Identify if there are domains manually excluded from out-noncdn-domains-intermediate.txt..."
if [ -f "$CDN_DOMAINS_EXCLUSIONS" ]; then
    grep -Fxv -f "$CDN_DOMAINS_EXCLUSIONS" "out-noncdn-domains-intermediate.txt"  > "out-noncdn-domains.txt"
else
    mv "out-noncdn-domains-intermediate.txt" "out-noncdn-domains.txt"
fi
rm "out-noncdn-domains-intermediate.txt"

verbose "Combining seed IPs for port scanning..."
echo "$seed_ips" | /root/go/bin/anew -q "out-resolvable-ips.csv"


num_all_ips=$(cat "out-resolvable-ips.csv" | wc -l)
verbose "Running masscan port scan for $num_all_ips IPs ..."
masscan -iL "out-resolvable-ips.csv"  --top-ports $TOP_TCP_PORTS --open -oG "$tmpfile2"
cat "$tmpfile2" | grep -iE  "Host:" >> "$tmpfile"
IFS=$'\n'
for l in $(cat "$tmpfile"); do
    ip_addr=$(echo "$l" | cut -d " " -f3)
    l_out=$(echo "$l" | tr -s "\r\n" " " | tr -s "," " " | tr -s "\"" "'")
    echo "\"$ip_addr\",\"$l_out\"" >>  "out-masscan-tcp.csv"
done

verbose "Running banner grab with netcat..."
IFS=$'\n'
for l in $(cat "out-masscan-tcp.csv"); do
    ip_to_scan=$(echo $l | cut -d '"' -f2)
    port_to_scan=$(echo "$l" | grep -ioE "[0-9]+/open" | cut -d '/' -f1)
    echo -e 'GET / HTTP/1.1\n\n\n\n' | timeout $NC_BANNER_TIMEOUT nc $ip_to_scan $port_to_scan 2>&1 1>"$tmpfile"
    banner=$(cat $tmpfile | tr -s "\r\n" " " | sed -r "s/[\"]/ /g")
    echo "\"$ip_to_scan\",\"$port_to_scan\",\"$banner\"" >> "out-banners.csv"
done

verbose "Get HTTP Domains and ports to scan.."
IFS=$'\n'
for l in $(cat "out-masscan-tcp.csv"); do
    ports=$(echo "$l" | grep -ioE "[0-9]+/open/tcp//(http|ssl)" | cut -d "/" -f1)
    ipaddr=$(echo "$l" | cut -d '"' -f2)
    hostnames=$(grep "$ipaddr" "out-dns-resolutions-domains.txt" | cut -d " " -f1)
    if [ -z "$hostnames" ]; then
        hostnames="$ipaddr"
    fi
    hostname_port_combos=""
    
    while IFS= read -r hostname; do
        for port in $ports; do
            if [[ $port =~ .*80 ]]; then
                echo "http://$hostname:$port" >> "out-http-hostnames-ports.txt"
            else
                echo "https://$hostname:$port" >> "out-http-hostnames-ports.txt"
            fi
        done        
    done <<< "$hostnames"
done 

verbose "Getting unique rows for scanning..."
cat "out-http-hostnames-ports.txt" |  sort | uniq > "$tmpfile"
mv "$tmpfile" "out-http-hostnames-ports.txt"

verbose "Scanning HTTP Domains and ports with webtech.."
source /opt/webtech/venv/bin/activate
IFS=$'\n'
for combo in $(cat "out-http-hostnames-ports.txt"); do 
    verbose "Scanning $combo with webtech..."
    webtech_out=$(webtech -u "$combo" --rua --og  | tr -s "\r\n" " " | tr -s "," " " | tr -s "\"" "'") 
    echo "\"$combo\",\"$webtech_out\"" >> "out-http-webtech.csv"
done
deactivate

verbose "Capturing HTTP Response Headers via curl..."
for combo in $(cat "out-http-hostnames-ports.txt"); do
    verbose "Scanning $combo with curl..."
    resp_headers=$(timeout "$MAX_CURL_TIMEOUT" curl -sLS -D - --connect-timeout "$MAX_CURL_TIMEOUT" "$combo" -o /dev/null 2>&1)
    resp_headers_out=""
    if [ ! -z "$resp_headers" ]; then
        resp_headers_out=$(echo "$resp_headers" | tr -s "\r\n" " " | tr -s "," " " | tr -s "\"" "'")
        echo "\"$combo\",\"$resp_headers_out\"" >> "out-http-resp-headers.csv"
    fi
done

